---
import Header from '@components/Header.astro'
import Editor from '@components/Editor.astro'
import NoteList from '@components/NoteList.astro'
import ActionsMenu from '@components/ActionMenu.astro'

// For loading published notes
const captureNoteId = RegExp(/notes?\/(.*)\/?/, 'g')
const noteId = captureNoteId.exec(Astro.url.pathname)?.[1] || false

const { editorVersion } = Astro.props
---

<Header editorVersion={editorVersion} />
<ActionsMenu />
<main>
	<Editor />
	<NoteList />
</main>
{noteId && <span id="id-storage" data-id={noteId} hidden />}
<span id="v" data-v={editorVersion || 1} hidden></span>
<script>
	// Bad code doesn't mean bad product üôèüèª
	import { registerServiceWorker } from '@scripts/utils/serviceWorkers'
	registerServiceWorker('/sw.js')

	import { createEditor } from '@scripts/editor/create'
	import { createEditor as createEditor2 } from '@scripts/editor2/create'
	import { initDragAndDrop } from '@scripts/editor/initDragAndDrop'
	import { reopenLastNote } from '@scripts/editor/reopenLastNote'
	import { initShortcuts } from '@scripts/editor/shortcuts'
	import { header } from '@scripts/header/elements'
	import { toggleAutosave } from '@scripts/note/save'
	import { updateNotesList } from '@scripts/render/notes'
	import { initStatus } from '@scripts/render/showStatus'
	import { initState, state } from '@scripts/state'
	import { setFocus } from '@scripts/utils/setFocus'
	import {
		initFocusListener,
		initNavigationListener,
		initUnloadListener,
	} from '@scripts/utils/systemListenters'
	import { initHeaderElements } from '@scripts/header/elements'
	import { initHeaderListeners } from '@scripts/header/listeners'

	await initState()
	initHeaderElements()
	initHeaderListeners()
	initStatus(header.headerEl)

	console.debug(`Current editor version: v${state.editorVersion}`)
	switch (state.editorVersion) {
		case '1':
		default: {
			state.editor = await createEditor()
			break
		}
		case '2': {
			state.editor2 = createEditor2()
			state.editorEl = state.editor2.options.element
				.firstChild as HTMLElement
			break
		}
	}

	reopenLastNote()
	updateNotesList()
	setFocus(state.editorEl)
	toggleAutosave(true)

	initShortcuts()
	initNavigationListener()
	initFocusListener()
	initUnloadListener()
	initDragAndDrop()

	// Markdown view toggle: show raw markdown in an overlay when
	// the `show-markdown-formatting` class is present on the editor.
	import { getMD } from '@scripts/versions/getMD'
	import { insertMD } from '@scripts/versions/insertMD'

	function initMarkdownToggle() {
		let overlay: HTMLElement | null = null
		let lastMD = ''

		function createOverlay() {
			if (overlay) return overlay
			overlay = document.createElement('div')
			overlay.className = 'markdown-overlay'
			overlay.innerHTML = `
				<div class="markdown-toolbar">
					<button class="md-apply">Apply</button>
					<button class="md-close">Close</button>
				</div>
				<textarea class="md-textarea" aria-label="Markdown view"></textarea>
			`

			const ta = overlay.querySelector('.md-textarea') as HTMLTextAreaElement
			const btnApply = overlay.querySelector('.md-apply') as HTMLButtonElement
			const btnClose = overlay.querySelector('.md-close') as HTMLButtonElement

			btnApply.addEventListener('click', async () => {
				const content = ta.value
				if (content !== lastMD) {
					await insertMD(content)
					lastMD = content
				}
				hideOverlay()
			})

			btnClose.addEventListener('click', () => {
				hideOverlay()
			})

			return overlay
		}

		function showOverlay(parentEl?: HTMLElement) {
			try {
				lastMD = getMD()
				const idEditor = document.getElementById('editor')
				const parent = parentEl || state.editorEl || idEditor || document.documentElement
				const ov = createOverlay()
				;(ov.querySelector('.md-textarea') as HTMLTextAreaElement).value = lastMD
				// Ensure we don't append overlay multiple times
				if (!parent.contains(ov)) parent.appendChild(ov)
				;(ov.querySelector('.md-textarea') as HTMLTextAreaElement).focus()
			} catch (e) {
				console.warn('showOverlay failed', e)
			}
		}

		function hideOverlay() {
			if (!overlay) return
			overlay.remove()
			overlay = null
		}

		function handleClassChange() {
			const cls = 'show-markdown-formatting'
			const idEditor = document.getElementById('editor')
			const candidates = [
				idEditor,
				state.editorEl,
				document.querySelector('.editor'),
				document.documentElement,
			].filter(Boolean) as HTMLElement[]

			const targetWithClass = candidates.find((el) => el && el.classList && el.classList.contains(cls))
			const enabled = Boolean(targetWithClass)

			if (enabled) {
				// Append overlay to the element that actually has the class so it visually sits
				// on top of the editor area where the user toggled formatting.
				showOverlay(targetWithClass || state.editorEl || idEditor || document.documentElement)
			} else {
				hideOverlay()
			}
		}

		const docObserver = new MutationObserver(handleClassChange)
		// Observe class changes on <html> and its subtree so toggles applied
		// to `#editor` or other descendants are also caught.
		docObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['class'], subtree: true })

		if (state.editorEl) {
			const elObserver = new MutationObserver(handleClassChange)
			elObserver.observe(state.editorEl, { attributes: true, attributeFilter: ['class'] })
		}

		handleClassChange()
	}

	initMarkdownToggle()
</script>
